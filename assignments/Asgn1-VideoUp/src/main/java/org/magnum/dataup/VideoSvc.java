package org.magnum.dataup;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.magnum.dataup.model.Video;
import org.magnum.dataup.model.VideoStatus;
import org.magnum.dataup.model.VideoStatus.VideoState;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.multipart.MultipartFile;


@Controller
public class VideoSvc {

	
	/**
	 * A map from video id to video object for easy retrieval using {id} HTTP path paramter.
	 */
	private Map<Long, Video> mVideos = new HashMap<Long, Video>();
	
	/**
	 * Class to handler saving/retrieving video binary
	 */
	private VideoFileManager mVideoManager;
	
	/**
	 * Constructor to initialize videoFileManager
	 * @throws IOException
	 */
	public VideoSvc() throws IOException
	{
		mVideoManager = VideoFileManager.get();
	}
	
	/**
	 * An Exception Handler that returns 404 response code when an IOException is thrown
	 * @param e
	 */
	@ExceptionHandler(IOException.class)
	@ResponseStatus(value=HttpStatus.NOT_FOUND)
	void handleException(IOException e) {}
	
	/**
	 * GET /video
	 * 
	 * Returns the list of videos that have been added to the server as JSON. 
	 * The list of videos does not have to be persisted across restarts of the server. 
	 * The list of Video objects should be able to be unmarshalled by the client into a Collection.
	 * The return content-type should be application/json, which will be the default if you use @ResponseBody
	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.GET)
	public @ResponseBody Collection<Video> getVideos() {
		return mVideos.values();
	}

	
	/**
	 * POST /video
	 * 
	 * The video metadata is provided as an application/json request body. 
	 * The JSON should generate a valid instance of the Video class when deserialized by Spring's default Jackson library.
	 * Returns the JSON representation of the Video object that was stored along with any updates to that object 
	 * made by the server.
	 * The server should generate a unique identifier for the Video object and assign it to the Video by calling 
	 * its setId(...) method.
	 * No video should have ID = 0. All IDs should be > 0.
	 * The returned Video JSON should include this server-generated identifier so that the client can refer to it 
	 * when uploading the binary mpeg video content for the Video.
	 * The server should also generate a "data url" for the Video. The "data url" is the url of the binary data 
	 * for a Video (e.g., the raw mpeg data). The URL should be the full URL for the video and not just the path 
	 * (e.g., http://localhost:8080/video/1/data would be a valid data url). 
	 * See the Hints section for some ideas on how to generate this URL.
	 * @param v
	 * @return
	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_SVC_PATH, method=RequestMethod.POST)
	public @ResponseBody Video postVideo(@RequestBody Video v) {
		if (v.getId() == 0) {
			v.setId(VideoSvcHelper.getNextId());
		}
		long id = v.getId();
		v.setDataUrl(VideoSvcHelper.getDataUrl(id));
		mVideos.put(id, v);
		return v;
	}

	
	/**
	 * POST /video/{id}/data
	 * 
	 * The binary mpeg data for the video should be provided in a multipart request as a part with the key "data". 
	 * The id in the path should be replaced with the unique identifier generated by the server for the Video. 
	 * A client MUST create a Video first by sending a POST to /video and getting the identifier for the newly created 
	 * Video object before sending a POST to /video/{id}/data.
	 * The endpoint should return a VideoStatus object with state=VideoState.READY if the request succeeds and 
	 * the appropriate HTTP error status otherwise. VideoState.PROCESSING is not used in this assignment but is present 
	 * in VideoState.
	 * Rather than a PUT request, a POST is used because, by default, Spring does not support a PUT with multipart data 
	 * due to design decisions in the Commons File Upload library: https://issues.apache.org/jira/browse/FILEUPLOAD-197
	 * @param id
	 * @param videoData
	 * @return
	 * @throws IOException
	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_DATA_PATH, method=RequestMethod.POST)
	public @ResponseBody VideoStatus setVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) long id, 
			@RequestPart(VideoSvcApi.DATA_PARAMETER) MultipartFile videoData) throws IOException 
	{
		InputStream in_str = videoData.getInputStream();
		Video v = mVideos.get(id);
		if (v != null) {
			mVideoManager.saveVideoData(v, in_str);
			return new VideoStatus(VideoState.READY);
		}
		else {
			throw new IOException();
		}
	}

	
	/**
	 * GET /video/{id}/data
	 * 
	 * Returns the binary mpeg data (if any) for the video with the given identifier. 
	 * If no mpeg data has been uploaded for the specified video, then the server should return a 404 status code.
	 * @param id
	 * @param response
	 * @throws IOException
	 */
	@RequestMapping(value=VideoSvcApi.VIDEO_DATA_PATH, method=RequestMethod.GET)
	public void getVideoData(
			@PathVariable(VideoSvcApi.ID_PARAMETER) long id,
			HttpServletResponse response) throws IOException 
	{
		Video v = mVideos.get(id);
		if (v != null && mVideoManager.hasVideoData(v)) {
			mVideoManager.copyVideoData(v, response.getOutputStream());
		}
		else {
			throw new IOException();
		}
	}

}
